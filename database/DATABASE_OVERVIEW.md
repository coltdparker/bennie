# Bennie Database Overview

## Architecture Overview

Bennie uses a hybrid database approach that integrates Supabase Auth with custom tables for language learning functionality. The system uses two main schemas:

1. `auth` schema (managed by Supabase)
2. `public` schema (our custom tables)

## Table Structure

### 1. Supabase Auth Table (`auth.users`)
- Managed by Supabase
- Contains core authentication data
- Primary key: `id` (UUID)
- Stores:
  - User authentication details
  - Email verification status
  - Raw user metadata (JSONB)

### 2. Custom Users Table (`public.users`)
```sql
CREATE TABLE public.users (
    auth_user_id uuid NOT NULL,
    name text NOT NULL,
    target_language text NOT NULL,
    proficiency_level integer NOT NULL DEFAULT 1,
    topics_of_interest text NOT NULL DEFAULT ''::text,
    learning_goal text,  -- Nullable (set during onboarding)
    motivation_goal text,  -- Nullable (set during onboarding)
    target_proficiency integer NOT NULL DEFAULT 50,
    email_schedule jsonb,  -- Stores schedule preferences
    is_active boolean NOT NULL DEFAULT true,
    instant_reply boolean NOT NULL DEFAULT false,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    CONSTRAINT users_pkey PRIMARY KEY (auth_user_id),
    CONSTRAINT users_auth_user_id_fkey FOREIGN KEY (auth_user_id)
        REFERENCES auth.users(id) ON DELETE CASCADE
);
```

### 3. Email History Table (`public.email_history`)
```sql
CREATE TABLE public.email_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    auth_user_id uuid NOT NULL,
    content text NOT NULL,
    is_from_bennie boolean NOT NULL,
    difficulty_level integer NOT NULL,
    is_evaluation boolean NOT NULL DEFAULT false,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT email_history_pkey PRIMARY KEY (id),
    CONSTRAINT email_history_auth_user_id_fkey FOREIGN KEY (auth_user_id)
        REFERENCES public.users(auth_user_id) ON DELETE CASCADE
);
```

## Relationships

1. `auth.users.id` → `public.users.auth_user_id` (1:1)
   - Each authenticated user has exactly one profile
   - CASCADE delete ensures data consistency

2. `public.users.auth_user_id` → `public.email_history.auth_user_id` (1:many)
   - Each user can have multiple email interactions
   - CASCADE delete removes email history when user is deleted

## Indexes
```sql
-- Users table indexes
CREATE INDEX idx_users_target_language ON public.users (target_language);
CREATE INDEX idx_users_created_at ON public.users (created_at);
CREATE INDEX idx_users_is_active ON public.users (is_active);
CREATE INDEX idx_users_auth_user_id ON public.users (auth_user_id);

-- Email history indexes
CREATE INDEX idx_email_history_auth_user_id ON public.email_history (auth_user_id);
CREATE INDEX idx_email_history_created_at ON public.email_history (created_at);
```

## Automatic User Creation

When a user is created in `auth.users`, an automatic trigger creates their profile in `public.users`:

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (
        auth_user_id,
        name,
        target_language,
        proficiency_level,
        topics_of_interest,
        learning_goal,
        motivation_goal,
        target_proficiency,
        email_schedule,
        is_active,
        instant_reply,
        created_at,
        updated_at
    ) VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'name', NEW.raw_user_meta_data->>'full_name', 'Anonymous'),
        COALESCE(NEW.raw_user_meta_data->>'target_language', 'english'),
        COALESCE((NEW.raw_user_meta_data->>'proficiency_level')::int, 1),
        COALESCE(NEW.raw_user_meta_data->>'topics_of_interest', ''),
        NEW.raw_user_meta_data->>'learning_goal',
        NEW.raw_user_meta_data->>'motivation_goal',
        COALESCE((NEW.raw_user_meta_data->>'target_proficiency')::int, 50),
        COALESCE(NEW.raw_user_meta_data->'email_schedule', '{"frequency": "weekly"}'::jsonb),
        true,
        false,
        NEW.created_at,
        NEW.updated_at
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Row Level Security (RLS)

### Users Table Policies
```sql
-- Select policy
CREATE POLICY "Users can view own profile"
    ON public.users FOR SELECT
    USING (auth.uid() = auth_user_id);

-- Update policy
CREATE POLICY "Users can update own profile"
    ON public.users FOR UPDATE
    USING (auth.uid() = auth_user_id)
    WITH CHECK (auth.uid() = auth_user_id);
```

### Email History Policies
```sql
-- Select policy
CREATE POLICY "Users can view own email history"
    ON public.email_history FOR SELECT
    USING (auth.uid() = auth_user_id);

-- Insert policy
CREATE POLICY "Users can insert own email history"
    ON public.email_history FOR INSERT
    WITH CHECK (auth.uid() = auth_user_id);
```

## Important Notes

1. **Email Schedule Format**
   - Stored as JSONB in `public.users.email_schedule`
   - Example format:
     ```json
     {
       "frequency": "weekly",
       "preferred_days": ["monday", "wednesday", "friday"],
       "preferred_time": "10:00"
     }
     ```

2. **Proficiency Levels**
   - Range: 1-100
   - Default starting level: 1
   - Default target level: 50

3. **Cascade Behavior**
   - Deleting from `auth.users` cascades to `public.users`
   - Deleting from `public.users` cascades to `email_history`

4. **Permissions**
   ```sql
   GRANT USAGE ON SCHEMA public TO authenticated;
   GRANT ALL ON public.users TO authenticated;
   GRANT ALL ON public.email_history TO authenticated;
   ```

## Testing

A test script is available at `database/create_test_user.sql` which demonstrates:
1. Creating a user in `auth.users`
2. Automatic creation in `public.users` via trigger
3. Creating test email history entries
4. Verifying relationships and data integrity 